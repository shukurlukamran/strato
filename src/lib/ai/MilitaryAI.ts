import type { StrategyIntent } from "@/lib/ai/StrategicPlanner";
import type { GameAction } from "@/types/actions";
import type { GameStateSnapshot } from "@/lib/game-engine/GameState";
import type { City, CountryStats } from "@/types/country";
import { RuleBasedAI } from "./RuleBasedAI";
import { DefaultPersonality, type AIPersonality } from "./Personality";
import { CityGenerator } from "@/lib/game-engine/CityGenerator";
import { CombatResolver } from "@/lib/game-engine/CombatResolver";

/**
 * Military AI Decision Maker
 * Uses rule-based logic to decide on military actions (recruitment, defense)
 */
export class MilitaryAI {
  private personality: AIPersonality;

  constructor(personality: AIPersonality = DefaultPersonality) {
    this.personality = personality;
  }

  /**
   * Decide military actions for this turn
   */
  decideActions(
    state: GameStateSnapshot,
    countryId: string,
    intent: StrategyIntent
  ): GameAction[] {
    const actions: GameAction[] = [];
    const stats = state.countryStatsByCountryId[countryId];
    
    if (!stats) return actions;

    // Analyze economic situation (military decisions need economic context)
    const analysis = RuleBasedAI.analyzeEconomicSituation(state, countryId, stats);
    
    // Calculate decision weights
    const weights = RuleBasedAI.calculateDecisionWeights(
      analysis,
      this.adjustPersonalityForIntent(intent),
      stats.resourceProfile
    );

    // DECISION: Military recruitment
    const recruitAmount = RuleBasedAI.decideMilitaryRecruitment(stats, analysis, weights);
    
    if (recruitAmount > 0) {
      // Use STANDARDIZED cost: 50 budget per strength point (same as player)
      const costPerStrength = 50; // ECONOMIC_BALANCE.MILITARY.COST_PER_STRENGTH_POINT
      const recruitCost = recruitAmount * costPerStrength;
      
      actions.push({
        id: '', // Will be auto-generated by database
        gameId: state.gameId,
        countryId,
        turn: state.turn,
        actionType: "military",
        actionData: {
          subType: "recruit",
          amount: recruitAmount,
          cost: recruitCost,
        },
        status: "pending",
        createdAt: new Date().toISOString(),
      });
    }

    // DECISION: Military attacks (AI-AI or AI-Player)
    const attackActions = this.decideAttacks(state, countryId, stats, weights);
    actions.push(...attackActions);

    return actions;
  }

  /**
   * Decide on military attacks against other countries
   * Uses rule-based logic (no LLM for AI-AI or AI-Player attacks)
   */
  private decideAttacks(
    state: GameStateSnapshot,
    countryId: string,
    stats: CountryStats,
    weights: any
  ): GameAction[] {
    const actions: GameAction[] = [];

    // Only consider attacks if military priority is high and we have sufficient strength
    if (weights.militaryPriority < 0.6 || stats.militaryStrength < 30) {
      return actions;
    }

    // Get our cities
    const ourCities = state.cities?.filter(c => c.countryId === countryId) || [];
    if (ourCities.length === 0) return actions;

    // Find potential targets (neighboring cities of other countries)
    const potentialTargets: Array<{ city: City; targetCountryId: string; targetStats: CountryStats }> = [];

    for (const enemyCity of state.cities || []) {
      if (enemyCity.countryId === countryId) continue; // Skip our own cities

      // Check if any of our cities can attack this enemy city
      const canAttack = ourCities.some(ourCity =>
        CityGenerator.areCitiesNeighbors(ourCity, enemyCity)
      );

      if (canAttack) {
        const targetStats = state.countryStatsByCountryId[enemyCity.countryId];
        if (targetStats) {
          potentialTargets.push({
            city: enemyCity,
            targetCountryId: enemyCity.countryId,
            targetStats,
          });
        }
      }
    }

    if (potentialTargets.length === 0) return actions;

    // Evaluate targets and select best one
    const bestTarget = this.selectBestAttackTarget(potentialTargets, stats, this.personality);

    if (bestTarget) {
      // Calculate military allocation (30-70% based on aggression and target value)
      const baseAllocation = 40;
      const aggressionBonus = this.personality.aggression * 20; // 0-20% bonus
      const militaryAllocation = Math.min(70, Math.max(30, baseAllocation + aggressionBonus));

      // Calculate attack cost
      const allocatedStrength = Math.floor(stats.militaryStrength * (militaryAllocation / 100));
      const attackCost = CombatResolver.calculateAttackCost(stats, bestTarget.city, allocatedStrength);

      // Only attack if we can afford it
      if (stats.budget >= attackCost.economicCost) {
        actions.push({
          id: '', // Will be auto-generated by database
          gameId: state.gameId,
          countryId,
          turn: state.turn,
          actionType: "military",
          actionData: {
            subType: "attack",
            targetCityId: bestTarget.city.id,
            attackingMilitaryAllocated: militaryAllocation,
            isLiveResolution: false, // AI attacks resolve at turn end
          },
          status: "pending",
          createdAt: new Date().toISOString(),
        });
      }
    }

    return actions;
  }

  /**
   * Select the best target for attack based on strategic value
   */
  private selectBestAttackTarget(
    targets: Array<{ city: City; targetCountryId: string; targetStats: CountryStats }>,
    ourStats: CountryStats,
    personality: AIPersonality
  ): { city: City; targetCountryId: string; targetStats: CountryStats } | null {
    if (targets.length === 0) return null;

    // Score each target
    const scoredTargets = targets.map(target => {
      let score = 0;

      // City value (resources + population)
      const cityResourceValue = Object.values(target.city.resourcesPerTurn).reduce((sum, val) => sum + val, 0);
      const cityPopulationValue = target.city.population / 10000;
      score += (cityResourceValue * 2 + cityPopulationValue) * 10;

      // Military advantage (our strength vs their strength)
      const strengthRatio = ourStats.militaryStrength / Math.max(1, target.targetStats.militaryStrength);
      if (strengthRatio > 1.5) {
        score += 50; // Strong advantage
      } else if (strengthRatio > 1.2) {
        score += 30; // Moderate advantage
      } else if (strengthRatio < 0.8) {
        score -= 30; // Disadvantage
      }

      // Personality modifiers
      if (personality.aggression > 0.7) {
        score += 20; // Aggressive AI attacks more
      }
      if (personality.riskTolerance < 0.3) {
        score -= 30; // Risk-averse AI avoids attacks
      }

      // Prefer weaker targets
      if (target.targetStats.militaryStrength < ourStats.militaryStrength * 0.7) {
        score += 40;
      }

      return { target, score };
    });

    // Sort by score and return best target
    scoredTargets.sort((a, b) => b.score - a.score);
    const bestScored = scoredTargets[0];

    // Only attack if score is positive
    if (bestScored && bestScored.score > 0) {
      return bestScored.target;
    }

    return null;
  }

  /**
   * Adjust personality weights based on strategic intent
   */
  private adjustPersonalityForIntent(intent: StrategyIntent): AIPersonality {
    const adjusted = { ...this.personality };

    switch (intent.focus) {
      case "military":
        // Military focus: more aggressive, more risk-tolerant
        adjusted.aggression = Math.min(1, adjusted.aggression + 0.3);
        adjusted.riskTolerance = Math.min(1, adjusted.riskTolerance + 0.2);
        break;
      case "economy":
      case "research":
        // Economic/research focus: less aggressive, save resources
        adjusted.aggression = Math.max(0, adjusted.aggression - 0.2);
        break;
      case "diplomacy":
        // Diplomatic focus: less aggressive
        adjusted.aggression = Math.max(0, adjusted.aggression - 0.3);
        adjusted.cooperativeness = Math.min(1, adjusted.cooperativeness + 0.2);
        break;
      case "balanced":
      default:
        // No adjustment for balanced approach
        break;
    }

    return adjusted;
  }
}

