import type { StrategyIntent } from "@/lib/ai/StrategicPlanner";
import type { GameAction } from "@/types/actions";
import type { GameStateSnapshot } from "@/lib/game-engine/GameState";
import type { City } from "@/types/city";
import { RuleBasedAI } from "./RuleBasedAI";
import { DefaultPersonality, type AIPersonality } from "./Personality";
import { calculateCityValue } from "@/types/city";
import { MilitaryCalculator } from "@/lib/game-engine/MilitaryCalculator";
import {
  extractLLMBans,
  extractLLMBansFromProhibitTokens,
  extractNumberRange,
  isOneTimeStep,
  instructionLooksConditional,
  mergeBans,
} from "@/lib/ai/LLMPlanInterpreter";
import type { LLMPlanItem } from "@/lib/ai/LLMStrategicPlanner";

/**
 * Military AI Decision Maker
 * Uses rule-based logic to decide on military actions (recruitment, defense, attacks)
 */
export class MilitaryAI {
  private personality: AIPersonality;
  private readonly debugLLMPlan: boolean;

  constructor(personality: AIPersonality = DefaultPersonality) {
    this.personality = personality;
    this.debugLLMPlan = process.env.LLM_PLAN_DEBUG === "1";
  }

  /**
   * Decide military actions for this turn
   * @param cities - All cities in the game (needed for attack target evaluation)
   */
  async decideActions(
    state: GameStateSnapshot,
    countryId: string,
    intent: StrategyIntent,
    cities: City[] = []
  ): Promise<GameAction[]> {
    const actions: GameAction[] = [];
    const stats = state.countryStatsByCountryId[countryId];
    
    if (!stats) return actions;

    // Track budget usage to enforce constraints
    let remainingBudget = stats.budget;

    // Analyze economic situation (military decisions need economic context)
    const analysis = RuleBasedAI.analyzeEconomicSituation(state, countryId, stats);
    
    // Calculate decision weights
    const weights = RuleBasedAI.calculateDecisionWeights(
      analysis,
      this.adjustPersonalityForIntent(intent),
      stats.resourceProfile
    );

    const bans = this.getEffectiveBans(intent);

    // Prefer structured plan items if available: execute next incomplete step(s) by ID.
    const planItems = intent.llmPlan?.planItems ?? [];
    const executed = new Set((intent.llmPlan?.executedStepIds ?? []).map((s) => String(s ?? "").trim()).filter(Boolean));
    const chosenThisTurn = new Set<string>();
    const recruitStep = this.pickNextExecutableMilitaryStep(planItems, executed, stats, bans, "recruit", chosenThisTurn);
    if (recruitStep) chosenThisTurn.add(recruitStep.id);
    const attackStep = this.pickNextExecutableMilitaryStep(planItems, executed, stats, bans, "attack", chosenThisTurn);

    const criticalDefenseNeed = analysis.isUnderDefended && analysis.militaryDeficit > 20;
    const hasLLMPlan = !!intent.llmPlan;
    // If an LLM plan exists, do NOT "freestyle recruit" every turn.
    // Recruit only when the LLM says so, or in critical defense emergencies.
    const allowRecruitment =
      (!bans.banRecruitment && criticalDefenseNeed) ||
      (recruitStep?.execution?.actionType === "military" &&
        (recruitStep.execution.actionData as any)?.subType === "recruit") ||
      (!hasLLMPlan && (intent.focus === "military" || intent.focus === "balanced"));
    const allowAttacks =
      (attackStep?.execution?.actionType === "military" &&
        (attackStep.execution.actionData as any)?.subType === "attack") ||
      (!hasLLMPlan && (intent.focus === "military" || intent.focus === "balanced"));

    // DECISION: Military recruitment
    const recruitAmount = allowRecruitment
      ? (this.extractRecruitAmountFromStep(recruitStep) ?? RuleBasedAI.decideMilitaryRecruitment(stats, analysis, weights))
      : 0;
    
    if (!bans.banRecruitment && recruitAmount > 0) {
      // Use STANDARDIZED cost: 50 budget per strength point (same as player)
      const costPerStrength = 50; // ECONOMIC_BALANCE.MILITARY.COST_PER_STRENGTH_POINT
      const alreadyHasRecruit = state.pendingActions.some(
        (a) =>
          a.countryId === countryId &&
          a.turn === state.turn &&
          a.status === "pending" &&
          a.actionType === "military" &&
          (a.actionData as Record<string, unknown>)?.subType === "recruit"
      );
      const finalRecruitAmount = alreadyHasRecruit ? 0 : Math.max(0, Math.floor(recruitAmount));
      const recruitCost = finalRecruitAmount * costPerStrength;
      
      if (finalRecruitAmount > 0 && recruitCost <= remainingBudget) {
        actions.push({
          id: '', // Will be auto-generated by database
          gameId: state.gameId,
          countryId,
          turn: state.turn,
          actionType: "military",
          actionData: {
            subType: "recruit",
            amount: finalRecruitAmount,
            cost: recruitCost,
            ...(recruitStep
              ? { llmStepId: recruitStep.id, llmStep: recruitStep.instruction, llmPlanTurn: intent.llmPlan?.turnAnalyzed }
              : {}),
          },
          status: "pending",
          createdAt: new Date().toISOString(),
        });
        remainingBudget -= recruitCost;
      }
    }

    // DECISION: Attack decisions (only if we have budget left)
    if (allowAttacks && cities.length > 0 && remainingBudget >= 200) { // Min attack cost: 100 base + buffer
      const attackAction = await this.decideAttack(
        state,
        countryId,
        intent,
        cities,
        remainingBudget,
        attackStep?.execution?.actionType === "military" &&
          (attackStep.execution.actionData as any)?.subType === "attack",
        attackStep?.id ?? null,
        attackStep?.instruction ?? null
      );
      if (attackAction) {
        const attackCost = Number((attackAction.actionData as Record<string, unknown>)?.cost ?? 0);
        if (attackCost <= remainingBudget) {
          actions.push(attackAction);
          remainingBudget -= attackCost;
        } else {
          console.log(`[MilitaryAI] ${state.countries.find(c => c.id === countryId)?.name} cannot afford attack (cost: ${attackCost}, remaining: ${remainingBudget})`);
        }
      }
    }

    return actions;
  }

  /**
   * Decide whether to attack and which city to target
   * Uses LLM for AI vs Player on strategic turns, rule-based otherwise
   */
  private async decideAttack(
    state: GameStateSnapshot,
    countryId: string,
    intent: StrategyIntent,
    cities: City[],
    remainingBudget: number,
    forcedByLLM: boolean,
    llmStepId: string | null,
    llmAttackStep: string | null
  ): Promise<GameAction | null> {
    const stats = state.countryStatsByCountryId[countryId];
    const country = state.countries.find(c => c.id === countryId);
    
    if (!stats || !country) return null;

    // Get neighboring enemy cities
    const neighboringCities = this.getAttackableNeighboringCities(
      countryId,
      cities,
      state
    );

    if (neighboringCities.length === 0) return null;

    // Check if we have minimum effective military strength and budget
    const effectiveStrength = MilitaryCalculator.calculateEffectiveMilitaryStrength(stats);
    const minMilitaryStrength = 50;
    const minBudget = 200; // Base attack cost + some buffer
    
    if (effectiveStrength < minMilitaryStrength || remainingBudget < minBudget) {
      return null; // Not strong enough or can't afford to attack
    }

    // Check if we already have a pending attack this turn
    const hasPendingAttack = state.pendingActions.some(
      a => a.countryId === countryId && 
           a.actionType === "military" && 
           (a.actionData as Record<string, unknown>)?.subType === "attack"
    );
    if (hasPendingAttack) return null; // One attack per turn

    // Determine if we should use LLM (AI vs Player on strategic turns) or rule-based
    const hasPlayerTarget = neighboringCities.some(city => {
      const owner = state.countries.find(ct => ct.id === city.countryId);
      return owner?.isPlayerControlled;
    });

    // If the higher-level (strategy) LLM plan explicitly wants an attack, we should
    // attempt it deterministically via rule-based logic (with slightly relaxed thresholds),
    // not by calling another LLM that might refuse.
    const useLLM = hasPlayerTarget && this.shouldUseLLMForAttack(state, countryId) && !forcedByLLM;

    if (useLLM) {
      return this.llmAttackDecision(state, countryId, neighboringCities, stats, remainingBudget);
    } else {
      // Use rule-based for AI vs AI OR AI vs Player on non-LLM turns
      // Rule-based logic works for both player and AI cities
      const forcedIntent = forcedByLLM ? { ...intent, focus: "military" as const } : intent;
      const action = this.ruleBasedAttackDecision(
        state,
        countryId,
        neighboringCities,
        stats,
        forcedIntent,
        remainingBudget,
        forcedByLLM
      );
      if (action && forcedByLLM && llmAttackStep) {
        if (llmStepId) (action.actionData as Record<string, unknown>).llmStepId = llmStepId;
        (action.actionData as Record<string, unknown>).llmStep = llmAttackStep;
        (action.actionData as Record<string, unknown>).llmPlanTurn = intent.llmPlan?.turnAnalyzed;
      }
      return action;
    }
  }

  /**
   * Get cities that are neighbors and can be attacked
   * Uses improved distance calculation that better approximates border proximity
   */
  private getAttackableNeighboringCities(
    attackerCountryId: string,
    cities: City[],
    state: GameStateSnapshot
  ): City[] {
    const attackerCountry = state.countries.find(c => c.id === attackerCountryId);
    if (!attackerCountry) return [];

    // Get attacker's cities to calculate proximity from ANY attacker city
    const attackerCities = cities.filter(c => c.countryId === attackerCountryId);
    if (attackerCities.length === 0) return [];

    // Get all cities owned by other countries
    const enemyCities = cities.filter(c => c.countryId !== attackerCountryId && !c.isUnderAttack);

    // Find cities that are "neighbors" - must be close to at least one attacker city
    // Attack range: 15 (matches player attack validation and better reflects visual borders)
    const attackRange = 15;
    
    const neighboring: City[] = [];
    for (const enemyCity of enemyCities) {
      // Check if this enemy city is close to ANY of the attacker's cities
      let isNeighbor = false;
      for (const attackerCity of attackerCities) {
        const distance = Math.sqrt(
          Math.pow(attackerCity.positionX - enemyCity.positionX, 2) +
          Math.pow(attackerCity.positionY - enemyCity.positionY, 2)
        );
        
        if (distance <= attackRange) {
          isNeighbor = true;
          break;
        }
      }
      
      if (isNeighbor) {
        neighboring.push(enemyCity);
      }
    }

    return neighboring;
  }

  /**
   * Rule-based attack decision (works for both AI vs AI and AI vs Player)
   * Used on non-LLM turns or when LLM is unavailable
   */
  private ruleBasedAttackDecision(
    state: GameStateSnapshot,
    countryId: string,
    neighboringCities: City[],
    stats: any,
    intent: StrategyIntent,
    remainingBudget: number,
    forcedByLLM: boolean
  ): GameAction | null {
    // Calculate effective strength for attacker
    const attackerEffectiveStrength = MilitaryCalculator.calculateEffectiveMilitaryStrength(stats);
    
    // Evaluate each potential target (works for both AI and player cities)
    const targets = neighboringCities.map(city => {
      const defenderStats = state.countryStatsByCountryId[city.countryId];
      if (!defenderStats) return null;

      const defenderEffectiveStrength = MilitaryCalculator.calculateEffectiveMilitaryStrength(defenderStats);
      const cityValue = calculateCityValue(city);
      const strengthRatio = attackerEffectiveStrength / defenderEffectiveStrength;
      const techAdvantage = stats.technologyLevel - defenderStats.technologyLevel;
      
      // Calculate attack score (higher = better target)
      let score = cityValue;
      
      // Prefer targets where we have strength advantage
      if (strengthRatio > 1.5) score *= 1.5;
      else if (strengthRatio > 1.2) score *= 1.2;
      else if (strengthRatio < 0.8) score *= 0.5; // Avoid if weaker
      
      // Tech advantage bonus
      if (techAdvantage > 2) score *= 1.3;
      else if (techAdvantage < -2) score *= 0.7;
      
      // Personality adjustment
      const adjustedPersonality = this.adjustPersonalityForIntent(intent);
      if (adjustedPersonality.aggression > 0.7) score *= 1.2; // Aggressive AI attacks more
      if (adjustedPersonality.riskTolerance < 0.3) score *= 0.8; // Risk-averse AI attacks less

      // Slight preference for player cities (more valuable targets)
      const owner = state.countries.find(c => c.id === city.countryId);
      if (owner?.isPlayerControlled) {
        score *= 1.1; // 10% bonus for attacking player cities
      }

      return {
        city,
        score,
        strengthRatio,
        defenderStats,
      };
    }).filter((t): t is NonNullable<typeof t> => t !== null);

    if (targets.length === 0) return null;

    // Sort by score and pick best target
    targets.sort((a, b) => b.score - a.score);
    const bestTarget = targets[0];

    // Only attack if score is above threshold
    const attackThreshold = forcedByLLM ? 60 : 100; // LLM-forced attacks can be slightly more opportunistic
    if (bestTarget.score < attackThreshold) return null;

    // Only attack if we have reasonable chance (strength ratio > 0.8)
    const minRatio = forcedByLLM ? 0.75 : 0.8;
    if (bestTarget.strengthRatio < minRatio) return null;

    // Decide allocation (30-70% of EFFECTIVE military strength)
    const adjustedPersonality = this.adjustPersonalityForIntent(intent);
    const baseAllocation = 0.3 + (adjustedPersonality.aggression * 0.4);
    const allocatedStrength = Math.floor(attackerEffectiveStrength * baseAllocation);
    const minAllocation = Math.floor(attackerEffectiveStrength * 0.3);
    const maxAllocation = Math.floor(attackerEffectiveStrength * 0.7);
    const finalAllocation = Math.max(minAllocation, Math.min(maxAllocation, allocatedStrength));

    // Calculate cost
    const cost = 100 + (finalAllocation * 10);
    
    // Check if we can afford it with remaining budget
    if (remainingBudget < cost) {
      console.log(`[MilitaryAI] Cannot afford attack: cost ${cost}, remaining budget ${remainingBudget}`);
      return null;
    }

    const targetOwner = state.countries.find(c => c.id === bestTarget.city.countryId);
    const isPlayerTarget = targetOwner?.isPlayerControlled;
    console.log(`[MilitaryAI] ${state.countries.find(c => c.id === countryId)?.name} attacking ${bestTarget.city.name} (${isPlayerTarget ? 'Player' : 'AI'}) with ${finalAllocation} strength (rule-based)`);

    return {
      id: '',
      gameId: state.gameId,
      countryId,
      turn: state.turn,
      actionType: "military",
      actionData: {
        subType: "attack",
        targetCityId: bestTarget.city.id,
        allocatedStrength: finalAllocation,
        attackerId: countryId,
        defenderId: bestTarget.city.countryId,
        cost,
        immediate: true,
        createdAt: new Date().toISOString(),
      },
      status: "pending",
      createdAt: new Date().toISOString(),
    };
  }

  /**
   * LLM-based attack decision (for AI vs Player on strategic turns)
   */
  private async llmAttackDecision(
    state: GameStateSnapshot,
    countryId: string,
    neighboringCities: City[],
    stats: any,
    remainingBudget: number
  ): Promise<GameAction | null> {
    const country = state.countries.find(c => c.id === countryId);
    if (!country) return null;

    // Filter to only player cities
    const playerCities = neighboringCities.filter(city => {
      const owner = state.countries.find(ct => ct.id === city.countryId);
      return owner?.isPlayerControlled;
    });

    if (playerCities.length === 0) {
      // No player cities to attack, fall back to rule-based
      return this.ruleBasedAttackDecision(
        state,
        countryId,
        neighboringCities,
        stats,
        { focus: "balanced", rationale: "" },
        remainingBudget,
        false
      );
    }

    try {
      const prompt = this.buildAttackPrompt(state, countryId, playerCities, stats);
      const response = await this.callLLM(prompt);
      const decision = this.parseAttackDecision(response, playerCities, stats);
      
      if (!decision) return null;

      console.log(`[MilitaryAI LLM] ${country.name} decided to attack ${decision.city.name} with ${decision.allocatedStrength} strength`);

      const cost = 100 + (decision.allocatedStrength * 10);
      if (remainingBudget < cost) {
        console.log(`[MilitaryAI LLM] Cannot afford attack: cost ${cost}, remaining budget ${remainingBudget}`);
        return null;
      }

      return {
        id: '',
        gameId: state.gameId,
        countryId,
        turn: state.turn,
        actionType: "military",
        actionData: {
          subType: "attack",
          targetCityId: decision.city.id,
          allocatedStrength: decision.allocatedStrength,
          attackerId: countryId,
          defenderId: decision.city.countryId,
          cost,
          immediate: true,
          createdAt: new Date().toISOString(),
        },
        status: "pending",
        createdAt: new Date().toISOString(),
      };
    } catch (error) {
      console.error(`[MilitaryAI LLM] Failed to get LLM decision, falling back to rule-based:`, error);
      // Fall back to rule-based
      return this.ruleBasedAttackDecision(
        state,
        countryId,
        neighboringCities,
        stats,
        { focus: "balanced", rationale: "" },
        remainingBudget,
        false
      );
    }
  }

  /**
   * Build prompt for LLM attack decision
   */
  private buildAttackPrompt(
    state: GameStateSnapshot,
    countryId: string,
    targetCities: City[],
    stats: any
  ): string {
    const country = state.countries.find(c => c.id === countryId);
    const effectiveStrength = MilitaryCalculator.calculateEffectiveMilitaryStrength(stats);
    
    const cityDescriptions = targetCities.map((city, index) => {
      const owner = state.countries.find(c => c.id === city.countryId);
      const ownerStats = state.countryStatsByCountryId[city.countryId];
      const ownerEffectiveStrength = ownerStats ? MilitaryCalculator.calculateEffectiveMilitaryStrength(ownerStats) : 0;
      const cityValue = calculateCityValue(city);
      const resourceList = Object.entries(city.perTurnResources)
        .map(([resource, amount]) => `${resource}: ${amount}/turn`)
        .join(", ");

      return `
${index + 1}. ${city.name} (Owner: ${owner?.name || "Unknown"})
   - Population: ${city.population.toLocaleString()}
   - Resources: ${resourceList || "None"}
   - Strategic Value: ${cityValue} points
   - Owner Military: ${ownerEffectiveStrength} (effective strength with tech bonuses)
   - Owner Tech Level: ${ownerStats?.technologyLevel || 0}`;
    }).join("\n");

    return `You are a military strategist deciding whether to attack an enemy city.

YOUR COUNTRY: ${country?.name || "Unknown"}
- Total Military Strength: ${effectiveStrength} (effective strength with tech bonuses)
- Technology Level: ${stats.technologyLevel}
- Budget: $${stats.budget.toLocaleString()}
- Available for Attack: ${Math.floor(effectiveStrength * 0.3)} - ${Math.floor(effectiveStrength * 0.7)} strength

POTENTIAL TARGETS:
${cityDescriptions}

ATTACK COSTS:
- Base cost: 100 budget
- Additional: 10 budget per strength point allocated
- Example: 50 strength = 600 budget total

IMPORTANT CONSIDERATIONS:
1. You can only attack ONE city per turn
2. You must allocate 30-70% of your military strength
3. Attacks are risky - you'll lose troops even if you win
4. Consider the strategic value vs the risk
5. The defender will respond with their own military allocation

DECISION REQUIRED:
Respond with ONLY a JSON object in this exact format:
{
  "target": "City Name",
  "allocation_percent": 45
}

Where:
- "target" is the exact name of the city to attack (from the list above)
- "allocation_percent" is a number between 30 and 70 (percentage of military to commit)

If you decide NOT to attack, respond with: {"target": null, "allocation_percent": 0}

Your decision:`;
  }

  /**
   * Parse LLM attack decision
   */
  private parseAttackDecision(
    response: string,
    targetCities: City[],
    stats: any
  ): { city: City; allocatedStrength: number } | null {
    try {
      // Try to extract JSON from response
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (!jsonMatch) return null;

      const decision = JSON.parse(jsonMatch[0]);
      
      if (!decision.target || decision.allocation_percent === 0) {
        return null; // Decided not to attack
      }

      const city = targetCities.find(c => c.name === decision.target);
      if (!city) return null;

      const percentage = Math.max(30, Math.min(70, decision.allocation_percent || 50));
      // Use effective strength for allocation
      const effectiveStrength = MilitaryCalculator.calculateEffectiveMilitaryStrength(stats);
      const allocatedStrength = Math.floor(effectiveStrength * (percentage / 100));

      return { city, allocatedStrength };
    } catch (error) {
      console.error(`[MilitaryAI] Failed to parse LLM response:`, error);
      return null;
    }
  }

  /**
   * Call LLM API (uses Google Gemini)
   */
  private async callLLM(prompt: string): Promise<string> {
    const apiKey = process.env.GOOGLE_GEMINI_API_KEY || process.env.GEMINI_API_KEY;
    
    if (!apiKey) {
      throw new Error("GOOGLE_GEMINI_API_KEY or GEMINI_API_KEY not configured");
    }

    // Use Gemini 2.5 Flash (matches existing LLM usage in codebase)
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: prompt }]
          }],
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 200,
          }
        }),
      }
    );

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'Unknown error');
      throw new Error(`LLM API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "";
    
    return text.trim();
  }

  /**
   * Determine if LLM should be used for attack decisions
   * Aligns with strategic planning schedule: turn 2, then every 7 turns (7, 14, 21, 28...)
   * On non-LLM turns, uses rule-based logic for consistency and cost efficiency
   * Rule-based logic still works for attacking players, just without LLM intelligence
   */
  private shouldUseLLMForAttack(
    state: GameStateSnapshot,
    countryId: string
  ): boolean {
    const turn = state.turn;
    // Use LLM on the same schedule as strategic planning
    // Turn 2, then every 7 turns (7, 14, 21, 28...)
    const isLLMTurn = turn === 2 || (turn >= 7 && turn % 7 === 0);
    
    if (!isLLMTurn) {
      // On non-LLM turns, use rule-based logic
      // This still allows AI to attack players, just with deterministic algorithm
      return false;
    }
    
    // Only use LLM if there are player-controlled targets
    // This makes AI vs Player combat more interesting and unpredictable on strategic turns
    return true;
  }

  private extractLLMMilitaryDirectives(
    rawSteps: string[],
    analysis: ReturnType<typeof RuleBasedAI.analyzeEconomicSituation>,
    currentMilitaryStrength: number,
    executedSteps: string[]
  ): {
    recruit: { amount: number; rawStep: string } | null;
    forceAttack: boolean;
    attackRawStep: string | null;
  } {
    const steps = Array.isArray(rawSteps) ? rawSteps : [];
    const executed = new Set((executedSteps ?? []).map((s) => String(s ?? "").trim()).filter(Boolean));

    let recruit: { amount: number; rawStep: string } | null = null;
    let forceAttack = false;
    let attackRawStep: string | null = null;

    for (const raw of steps) {
      const step = String(raw ?? "").trim();
      if (!step) continue;

      if (!recruit && this.looksLikeRecruitStep(step)) {
        // Case A: "reach X strength" (target-based) -> recruit only what's needed, stop once reached.
        const target = this.extractTargetStrength(step);
        if (target !== null) {
          if (currentMilitaryStrength >= target) {
            // Completed: move on to next advice
            continue;
          }
          const needed = Math.max(0, target - currentMilitaryStrength);
          const amount = Math.max(0, Math.min(50, needed));
          if (amount > 0) {
            recruit = { amount, rawStep: step };
          }
        } else {
          // Case B: "recruit N additional" (amount-based, usually one-time per plan)
          const range = extractNumberRange(step);
          const parsed = range ? range.min : this.extractFirstNumber(step);
          const fallback =
            analysis.militaryDeficit > 0 ? Math.min(25, Math.max(5, Math.ceil(analysis.militaryDeficit / 2))) : 10;
          const oneTime = isOneTimeStep(step);

          if (oneTime && executed.has(step)) {
            continue; // already executed once for this plan
          }

          const amount = Math.max(0, Math.min(50, parsed ?? fallback));
          if (amount > 0) {
            recruit = { amount, rawStep: step };
          }
        }
      }

      if (!forceAttack && this.looksLikeAttackStep(step)) {
        forceAttack = true;
        attackRawStep = step;
      }

      if (recruit && forceAttack) break;
    }

    return { recruit, forceAttack, attackRawStep };
  }

  private getEffectiveBans(intent: StrategyIntent): ReturnType<typeof extractLLMBans> {
    let bans = extractLLMBans(intent.llmPlan?.recommendedActions ?? []);
    const planItems = intent.llmPlan?.planItems ?? [];
    for (const item of planItems) {
      if (item && item.kind === "constraint") {
        bans = mergeBans(bans, extractLLMBansFromProhibitTokens(item.effects?.prohibit, item.instruction));
        bans = mergeBans(bans, extractLLMBans([item.instruction]));
      }
    }
    return bans;
  }

  private pickNextExecutableMilitaryStep(
    planItems: LLMPlanItem[],
    executed: Set<string>,
    stats: { technologyLevel: number; infrastructureLevel?: number; militaryStrength: number; budget: number },
    bans: ReturnType<typeof extractLLMBans>,
    requiredSubType: "recruit" | "attack",
    chosenThisTurn?: Set<string>
  ): Extract<LLMPlanItem, { kind: "step" }> | null {
    if (!Array.isArray(planItems) || planItems.length === 0) return null;
    const steps = planItems
      .filter((i): i is Extract<LLMPlanItem, { kind: "step" }> => i.kind === "step")
      .slice()
      .sort((a, b) => (a.priority ?? 999) - (b.priority ?? 999));

    if (this.debugLLMPlan) {
      const coverage = {
        total: steps.length,
        executed: 0,
        stopMet: 0,
        noExecution: 0,
        wrongDomain: 0,
        whenUnmet: 0,
        banned: 0,
        actionable: 0,
      };

      const skippedReasons: Record<string, string[]> = {
        stopMet: [],
        executed: [],
        noExecution: [],
        wrongDomain: [],
        whenUnmet: [],
        banned: [],
      };

      for (const s of steps) {
        if (this.isStopConditionMet(s.stop_when, stats)) {
          coverage.stopMet++;
          skippedReasons.stopMet.push(s.id);
          continue;
        }
        // If stop_when exists, allow repeated execution until completion.
        if (!s.stop_when && executed.has(s.id)) {
          coverage.executed++;
          skippedReasons.executed.push(s.id);
          continue;
        }
        if (chosenThisTurn?.has(s.id)) {
          coverage.executed++;
          skippedReasons.executed.push(s.id);
          continue;
        }
        if (!s.execution) {
          coverage.noExecution++;
          skippedReasons.noExecution.push(`${s.id} (${s.instruction.substring(0, 50)}...)`);
          continue;
        }
        if (s.execution.actionType !== "military") {
          coverage.wrongDomain++;
          skippedReasons.wrongDomain.push(s.id);
          continue;
        }
        // Safety guard: conditional instructions must provide `when`
        if (!s.when && instructionLooksConditional(s.instruction)) {
          coverage.whenUnmet++;
          skippedReasons.whenUnmet.push(s.id);
          continue;
        }
        if (!this.isWhenConditionMet(s.when, stats)) {
          coverage.whenUnmet++;
          skippedReasons.whenUnmet.push(s.id);
          continue;
        }
        const subType = (s.execution.actionData as any)?.subType;
        if (subType === "recruit" && bans.banRecruitment) {
          coverage.banned++;
          skippedReasons.banned.push(`${s.id} (recruitment banned)`);
          continue;
        }
        // (attack bans could be added later if you implement prohibit:["attack"] execution blocking)
        if (subType !== requiredSubType) {
          coverage.wrongDomain++;
          skippedReasons.wrongDomain.push(`${s.id} (need ${requiredSubType}, got ${subType})`);
          continue;
        }
        coverage.actionable++;
      }

      console.log(`[LLM Plan Debug] Military coverage (${requiredSubType}):`, coverage);
      
      // Log non-executable steps so they're visible
      if (skippedReasons.noExecution.length > 0) {
        console.log(`[LLM Plan Debug] Non-executable military steps:`, skippedReasons.noExecution);
      }
      if (skippedReasons.banned.length > 0) {
        console.log(`[LLM Plan Debug] Banned military steps:`, skippedReasons.banned);
      }
    }

    for (const s of steps) {
      if (this.isStopConditionMet(s.stop_when, stats)) continue;
      if (!s.stop_when && executed.has(s.id)) continue;
      if (chosenThisTurn?.has(s.id)) continue;
      if (!s.execution) continue;
      if (s.execution.actionType !== "military") continue;
      // Safety guard: conditional instructions must provide `when`
      if (!s.when && instructionLooksConditional(s.instruction)) continue;
      if (!this.isWhenConditionMet(s.when, stats)) continue;

      const subType = (s.execution.actionData as any)?.subType;
      if (subType !== requiredSubType) continue;
      if (subType === "recruit" && bans.banRecruitment) continue;
      
      if (this.debugLLMPlan) {
        console.log(`[LLM Plan Debug] Selected military step: ${s.id} (${requiredSubType}, priority: ${s.priority ?? 'none'}, instruction: "${s.instruction.substring(0, 60)}...")`);
      }
      return s;
    }
    
    if (this.debugLLMPlan && steps.length > 0) {
      console.log(`[LLM Plan Debug] No actionable ${requiredSubType} step found (all ${steps.length} steps filtered out)`);
    }
    return null;
  }

  private isWhenConditionMet(
    when: Record<string, unknown> | undefined,
    stats: { technologyLevel: number; infrastructureLevel?: number; militaryStrength: number; budget: number }
  ): boolean {
    if (!when) return true;
    const tech = stats.technologyLevel;
    const infra = stats.infrastructureLevel ?? 0;
    const mil = stats.militaryStrength;
    const budget = stats.budget;
    const techGte = typeof when.tech_level_gte === "number" ? when.tech_level_gte : undefined;
    const infraGte = typeof when.infra_level_gte === "number" ? when.infra_level_gte : undefined;
    const milGte = typeof when.military_strength_gte === "number" ? when.military_strength_gte : undefined;
    const budgetGte = typeof when.budget_gte === "number" ? when.budget_gte : undefined;
    if (typeof techGte === "number" && tech < techGte) return false;
    if (typeof infraGte === "number" && infra < infraGte) return false;
    if (typeof milGte === "number" && mil < milGte) return false;
    if (typeof budgetGte === "number" && budget < budgetGte) return false;
    return true;
  }

  private isStopConditionMet(
    stop: Record<string, unknown> | undefined,
    stats: { technologyLevel: number; infrastructureLevel?: number; militaryStrength: number; budget: number }
  ): boolean {
    if (!stop) return false;
    const tech = stats.technologyLevel;
    const infra = stats.infrastructureLevel ?? 0;
    const mil = stats.militaryStrength;
    const budget = stats.budget;
    const techGte = typeof stop.tech_level_gte === "number" ? stop.tech_level_gte : undefined;
    const infraGte = typeof stop.infra_level_gte === "number" ? stop.infra_level_gte : undefined;
    const milGte = typeof stop.military_strength_gte === "number" ? stop.military_strength_gte : undefined;
    const budgetGte = typeof stop.budget_gte === "number" ? stop.budget_gte : undefined;
    if (typeof techGte === "number" && tech >= techGte) return true;
    if (typeof infraGte === "number" && infra >= infraGte) return true;
    if (typeof milGte === "number" && mil >= milGte) return true;
    if (typeof budgetGte === "number" && budget >= budgetGte) return true;
    return false;
  }

  private extractRecruitAmountFromStep(step: Extract<LLMPlanItem, { kind: "step" }> | null): number | null {
    if (!step?.execution || step.execution.actionType !== "military") return null;
    const subType = (step.execution.actionData as any)?.subType;
    if (subType !== "recruit") return null;
    const amount = Number((step.execution.actionData as any)?.amount);
    if (!Number.isFinite(amount)) return null;
    return Math.max(0, Math.min(50, Math.floor(amount)));
  }

  private looksLikeRecruitStep(step: string): boolean {
    return /\b(recruit|train|conscri|build\s+army|raise\s+army|mobiliz)\b/i.test(step);
  }

  private looksLikeAttackStep(step: string): boolean {
    return /\b(attack|invad|conquer|capture|offensive|seize)\b/i.test(step);
  }

  private extractFirstNumber(step: string): number | null {
    const match = step.match(/\b(\d{1,3})\b/);
    if (!match?.[1]) return null;
    const n = Number(match[1]);
    if (!Number.isFinite(n)) return null;
    return Math.floor(n);
  }

  private extractTargetStrength(step: string): number | null {
    // Example formats:
    // - "Recruit military units to reach 55 strength"
    // - "Build up to 80 military strength"
    const reach = step.match(/\b(?:reach|to)\s+(\d{1,3})\s*(?:military\s+)?strength\b/i);
    if (reach?.[1]) {
      const n = Number(reach[1]);
      if (Number.isFinite(n)) return Math.floor(n);
    }
    const upTo = step.match(/\bup\s+to\s+(\d{1,3})\s*(?:military\s+)?strength\b/i);
    if (upTo?.[1]) {
      const n = Number(upTo[1]);
      if (Number.isFinite(n)) return Math.floor(n);
    }
    return null;
  }

  /**
   * Adjust personality weights based on strategic intent
   */
  private adjustPersonalityForIntent(intent: StrategyIntent): AIPersonality {
    const adjusted = { ...this.personality };

    switch (intent.focus) {
      case "military":
        // Military focus: more aggressive, more risk-tolerant
        adjusted.aggression = Math.min(1, adjusted.aggression + 0.3);
        adjusted.riskTolerance = Math.min(1, adjusted.riskTolerance + 0.2);
        break;
      case "economy":
      case "research":
        // Economic/research focus: less aggressive, save resources
        adjusted.aggression = Math.max(0, adjusted.aggression - 0.2);
        break;
      case "diplomacy":
        // Diplomatic focus: less aggressive
        adjusted.aggression = Math.max(0, adjusted.aggression - 0.3);
        adjusted.cooperativeness = Math.min(1, adjusted.cooperativeness + 0.2);
        break;
      case "balanced":
      default:
        // No adjustment for balanced approach
        break;
    }

    return adjusted;
  }
}
